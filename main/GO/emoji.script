go.property("speed", 8)
go.property("wait",  4)
go.property("score", 1)


emojis = 10 ; level = 1  -- dummy values, will be overwriten anyway


-- local functions:
local get_new_menu_emoji_pos, get_new_emoji_pos, emoji_waiting, sprite_flip




function init(self)
	self.active         = true
	self.delay          = rnd.range(2, (emojis / 2) - (level / 4))
	self.wait_timeout   = 0
	self.waiting        = false
	self.going_away     = false
	self.need_pos_check = false

	msg.post("#sprite", "play_animation", {id = hash("e"..rnd.range(1, emoji_in_atlas))})

	-- movement for main menu
	if main_menu_visible == true then
		msg.post("#collide_emoji", "disable")
		sprite.set_constant("#sprite", "tint", vmath.vector4(.32, .36, .52, 1))
		timer.delay(1.82, false, function() msg.post("#collide_emoji", "enable") end)
		go.set_scale(math.random(36, 360) / 100)
		go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_INOUTSINE, 1.5, rnd.range(6, 14) / 10)
		get_new_menu_emoji_pos(self, go.EASING_INOUTSINE, go.EASING_OUTSINE)
	else
		self.emoji_id = msg.url(nil, go.get_id(), "collide_emoji")
		self.particle_id = msg.url(nil, go.get_id(), "particle")
		sprite.set_constant("#sprite", "tint", vmath.vector4(1,1,1,1))
		get_new_emoji_pos(self, go.EASING_INOUTSINE, go.EASING_OUTSINE, self.delay)
	end
end




function update(self, dt)
	local pos, pos_x, pos_y

	-- disable emojis at the end of main menu
	if main_menu_visible == true then
		--msg.post("#collide_weapon", "disable")
		if allow_title_emojis == false and self.active == true then
			self.active = false
			msg.post(msg.url(nil, go.get_id(), "collide_emoji"), "disable")

			pos_x, pos_y = get_offscreen_pos(400)
			go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, math.random(36, 360) / 100, go.EASING_INOUTSINE, 1.5, rnd.range(6, 14) / 10)
			go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(pos_x, pos_y, 1), go.EASING_INOUTSINE, 1.5, rnd.range(6, 14) / 10, function ()
				go.delete()
			end)
		end

	-- checks if emoji is on-screen, to determine if it's going to wait state, if not - get new on-screen position
	else
		pos = go.get_position()

		if pos.x > 40 and pos.x < window_w - 40 and pos.y > 40 and pos.y < window_h - 70 and self.active == true and self.going_away == false then
			self.need_pos_check = false
			msg.post(self.emoji_id, "enable")
		else
			self.need_pos_check = true
			msg.post(self.emoji_id, "disable")
		end
	end
end




function get_new_menu_emoji_pos(self, easing1, easing2)
	local pos_x, pos_y
	local radius, x, y

	radius = rnd.range(40, 160)
	time = rnd.range(2, 12)

	pos_x = rnd.range(50 + 20, window_w - 20 - 50)
	pos_y = rnd.range(50 + 20, window_h - 20 - 50)
	sprite_flip(pos_x)

	go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, pos_y, easing1, time)
	go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, pos_x - radius, easing2, time * 0.5, 0, function()
		go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, pos_x, easing2, time * 0.5, 0, function()
			if allow_title_emojis == true then get_new_menu_emoji_pos(self, 0, easing1, easing2) end
		end)
	end)
end




function get_new_emoji_pos(self, easing1, easing2, delay)
	if self.active == true then
		local pos_x, pos_y
		local radius, x, y

		radius = rnd.range(40, 120)
		--time = self.speed + rnd.range(-(speed/3), speed/3)

		if self.going_away == false then
			time = self.speed - (self.speed * (speed / 100))
			pos_x = rnd.range(80 + 50, window_w - 80 - 50)
			pos_y = rnd.range(80 + 50, window_h - 120 - 50)
		else
			time = (self.speed - (self.speed * (speed / 100))) * 1.46
			pos_x, pos_y = get_offscreen_pos(100, true, go.get_position())
		end
		sprite_flip(pos_x)

		go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, pos_y, easing1, time, delay)
		go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, pos_x - radius, easing2, time * 0.5, delay, function()
			go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, pos_x, easing2, time * 0.5, 0, function()
				if self.going_away == false then
					self.need_pos_check = false
					emoji_waiting(self)
				else
					if health > 0 then
						sound.play("game_layer1:/main#energy_loss", {speed = math.random(80, 120) / 100})
						emojis_left = emojis_left - 1 ; escaped = escaped + 1
						health = health - 1
						particlefx.stop(self.particle_id)
						msg.post("game_layer2:/main#game_gui", "display_update", {stat = "emoji_left"})
					end
				end
			end)
		end)
	end
end




function emoji_waiting(self)
	if self.active == true then
		if self.wait_timeout == 0 then
			self.wait_timeout = (self.wait - (self.wait * speed / 100)) + socket.gettime()
			--self.wait_timeout = socket.gettime() + wait
		end

		self.waiting = true
		particlefx.play(self.particle_id)
		particlefx.set_constant(self.particle_id, "emitter", "tint", vmath.vector4(.28, .32, .62, .6))

		if socket.gettime() >= self.wait_timeout and self.going_away == false then
			self.waiting = false
			self.going_away = true
			particlefx.set_constant(self.particle_id, "emitter", "tint", vmath.vector4(1, .6, .2, .64))

			go.animate(".", "scale", go.PLAYBACK_ONCE_FORWARD, go.get_scale() * 1.32, go.EASING_INSINE, 1, 0, function()
				msg.post(self.emoji_id, "disable")
				sound.play("game_layer1:/main#emoji_going_away", {speed = math.random(80, 120) / 100})
				get_new_emoji_pos(self, go.EASING_INOUTSINE, go.EASING_OUTSINE, .1)
			end)
		else
			local pos = go.get_position()
			pos.x = pos.x + math.random(-22, 22) ; 	pos.y = pos.y + math.random(-22, 22)
			go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_INOUTSINE, math.random(2, 4), 0, function()
				if self.going_away == false then
					emoji_waiting(self)
				end
			end)
		end
	end
end




function sprite_flip(pos)
	sprite.set_hflip(".", go.get_position().x < pos)
end




function on_message(self, message_id, message, sender)
	local a, z, id, pos, pos_x, pos_y, force, distance, time, score_calc
	local blood_scale = {20, 15, 60, 45}


	-- for main menu
	if main_menu_visible == true then
		if message.group == hash("menu_right_click") then
			force = rnd.range(120, 160)
			distance = rnd.range(20, 28) / 10
			time = rnd.range(10, 24) / 10
		else 
			force = rnd.range(60, 125)
			distance = rnd.range(9, 16) / 10
			time = rnd.range(14, 40) / 10
		end

		if message_id == hash("contact_point_response") and self.active == true then
			go.set_position(go.get_position() + message.normal * message.distance)
			pos = go.get_position() + (message.normal * force) * (message.distance * distance)
			sprite_flip(pos.x)
			go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_OUTSINE, time, 0, function()
				get_new_menu_emoji_pos(self, go.EASING_INOUTSINE, go.EASING_OUTSINE)
			end)
		end


	-- for levels
	else
		if message.group == hash("weapon") and self.active == true then

			emojis_left = emojis_left - 1 ; killed = killed + 1
			score_calc = self.score
			if self.waiting == false and self.going_away == false then score_calc = score_calc * 3 end
			if self.waiting == true then score_calc = score_calc * 2 end
			score = score + score_calc

			msg.post("game_layer2:/main#game_gui", "display_update")
			sound.play("game_layer1:/main#squeak1", { speed = math.random(60, 120) / 100, gain = math.random(80, 120) / 100 })
			particlefx.stop(self.particle_id)

			self.active = false
			msg.post(self.emoji_id, "disable")

			go.cancel_animations(".", "position")
			go.cancel_animations(".", "scale")
			pos = go.get_position()
			go.set_position(vmath.vector3(pos.x, pos.y, .8))
			go.set_rotation(vmath.quat_rotation_z(math.random(1, 360)))

			for a = 1, 4 do
				-- blood 1 and 2 is under sprite
				-- blood 4 is under cursor
				if a <= 2 then z = .4 else z = .9 end
				if a == 4 then
					pos_x = cursor_x
					pos_y = cursor_y
				else
					pos_x = pos.x + math.random(-8, 8)
					pos_y = pos.y + math.random(-8, 8)
				end

				msg.post("game_layer2:/main#ctrl", "spawn_blood", {a = a, x = pos_x, y = pos_y, z = z, scale = blood_scale[a]})
			end


		elseif message_id == hash("contact_point_response") and self.active == true then
			force = rnd.range(80, 120)
			distance = (rnd.range(8, 12) / 10)
			distance = distance - (distance * speed / 100)
			time = rnd.range(12, 20) / 10
			time = time + (time * speed / 100)

			sound.play("game_layer1:/main#emoji_collide", {speed = math.random (12, 18) / 10})
			go.set_position(go.get_position() + message.normal * message.distance)
			pos = go.get_position() + (message.normal * force) * (message.distance * distance)
			go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_OUTSINE, time, 0, function()
				if self.need_pos_check == true then
					self.wait_timeout = 0
					go.cancel_animations(".", "position")
					get_new_emoji_pos(self, go.EASING_INOUTSINE, go.EASING_OUTSINE, 0)
				else
					emoji_waiting(self)
				end
			end)


		elseif message_id == hash("clean_emojis") then
			for _, id in ipairs(emoji_table) do
				go.animate(id, "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(0,0,0), go.EASING_INSINE, 2, 0, function()
					go.delete(id)
				end)
			end
		end
	end
end
